"""
Generic JSON-LD registry system.

This module provides a generic registry pattern for mapping JSON-LD IRIs to factory functions,
with support for namespace abbreviations and thread-local context. It's designed to be
schema-agnostic and extractable as a standalone library.
"""

from collections.abc import Callable
import inspect
import logging
from typing import Any, TypeVar

F = TypeVar("F", bound=Callable[..., Any])

# Global namespace context
_current_namespace_iri: str | None = None


def set_namespace(namespace_iri: str) -> None:
    """Set namespace for subsequent registrations in a module. Call this at the
    top of the module.

    Args:
        namespace_iri: Full namespace IRI (e.g., "https://example.com/schemas/")

    Note:
        Prefixes for JSON-LD serialization are automatically generated by the
        abbreviation system when needed, optimized per serialization call.
    """
    logging.debug("Registering namespace: ", namespace_iri)
    global _current_namespace_iri
    _current_namespace_iri = namespace_iri.rstrip("/") + "/"  # Ensure trailing slash


class RegistryError(Exception):
    """Base exception for registry errors."""

    pass


class UnknownIRIError(RegistryError):
    """Raised when attempting to create object with unknown IRI."""

    def __init__(self, iri: str, available: list | None = None):
        self.iri = iri
        self.available = available or []
        super().__init__(f"Unknown IRI: '{iri}'")


class FactoryValidationError(RegistryError):
    """Raised when factory function fails to create object."""

    def __init__(self, iri: str, data: Any):
        self.iri = iri
        self.data = data

        msg = f"Factory for '{iri}' failed with data {data}"
        super().__init__(msg)


class Registry:
    """Registry supporting IRI→factory mapping and bidirectional type→short_name mapping."""

    def __init__(self):
        self._factories: dict[str, Callable[..., Any]] = {}
        self._type_to_iri: dict[type, str] = {}

    def register(self, name_override: str | None = None):
        """Decorator for registering factory functions with current namespace.

        Args:
            name_override: Optional name override (e.g., "mapAxis" for function named "map_axis")

        Factory Function Requirements:
            Dict input → kwargs expansion: `factory(**data)`
            Non-dict input → direct argument: `factory(data)`

            Supported: `def func(data: Type) -> Result`
            Supported: `def func(param1: Type, param2: Type = default) -> Result`
            Supported: `def func() -> Result`
            Avoid: `def func(config: dict) -> Result` (conflicts with kwargs expansion)
        """

        def decorator(func: F) -> F:
            # Get current namespace from global context
            namespace_iri = _current_namespace_iri

            if not namespace_iri:
                raise RuntimeError(
                    f"No namespace set for function '{func.__name__}'. "
                    "Call set_namespace() first in this module."
                )

            # Use override name or derive from function name
            local_name = name_override or func.__name__

            # Build full IRI
            full_iri = f"{namespace_iri}{local_name}"

            # Check for collisions - prevent duplicate registrations
            if full_iri in self._factories:
                existing_func = self._factories[full_iri]
                if existing_func != func:
                    raise RuntimeError(
                        f"IRI '{full_iri}' is already registered with a different factory function. "
                        f"Existing: {existing_func.__name__}, New: {func.__name__}. "
                        f"Use a different local name or namespace to avoid conflicts."
                    )
                # Same function re-registered - allow it (idempotent)
                return func

            # Register the factory
            self._factories[full_iri] = func

            # Register type mapping for reverse lookup during serialization
            return_type = self._get_return_type(func)
            if return_type:
                self._type_to_iri[return_type] = full_iri

            return func

        # Support both @register and @register("name")
        if callable(name_override):
            # @register (no parentheses)
            func = name_override
            name_override = None
            return decorator(func)
        else:
            # @register("name") or @register()
            return decorator

    def create(self, iri: str, data: Any) -> Any:
        """Create object from IRI and data.

        Args:
            iri: Full IRI of the object type
            data: Input data (will be passed to factory function)

        Returns:
            Created object from registered factory

        Raises:
            UnknownIRIError: If IRI not registered
            FactoryValidationError: If factory function fails
        """
        if iri not in self._factories:
            available = list(self._factories.keys())
            raise UnknownIRIError(iri, available)

        try:
            factory = self._factories[iri]

            if isinstance(data, dict):
                return factory(**data)
            else:
                return factory(data)
        except Exception as e:
            raise FactoryValidationError(iri, data) from e

    def get_iri_for_object(self, obj: Any) -> str | None:
        """Get IRI for object type.

        Args:
            obj: Object instance to find IRI for

        Returns:
            IRI if registered, None otherwise
        """
        obj_type = type(obj)
        return self._type_to_iri.get(obj_type)

    def get_registered_types(self) -> set[type]:
        """Get all registered object types."""
        return set(self._type_to_iri.keys())

    def get_registered_iris(self) -> set[str]:
        """Get all registered IRIs."""
        return set(self._factories.keys())

    def _get_return_type(self, func: Callable) -> type | None:
        """Extract return type from function annotation."""
        sig = inspect.signature(func)
        return_annotation = sig.return_annotation

        if return_annotation != inspect.Signature.empty:
            # Handle typing generics - just return the base type
            origin = getattr(return_annotation, "__origin__", None)
            if origin is None:
                return return_annotation

        return None


# Global registry instance
registry = Registry()

# Export the register decorator bound to global registry
register = registry.register
