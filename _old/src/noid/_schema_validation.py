"""
Validation mixins for generated schema classes.

This module provides a post-generation validation layer that extends the automatically
generated Pydantic models from JSON Schema with additional validation logic that
cannot be expressed in JSON Schema alone.

## Architecture Overview

The NOID project uses a three-layer validation architecture:

1. **JSON Schema (_schema.py)**: Auto-generated Pydantic models from JSON Schema files
   - Generated by datamodel-codegen from schemas/*.json files
   - Contains basic type validation, constraints, and structure
   - Should never be edited manually (marked as generated code)

2. **Validation Mixins (_schema_validation.py)**: This module
   - Contains mixins that add business logic validation
   - Uses Pydantic's @model_validator for complex cross-field validation
   - Implements constraints that are difficult/impossible to express in JSON Schema

3. **Public API (schema.py)**: Validated public classes
   - Combines generated models with validation mixins
   - Provides the public API that users import from noid
   - Classes inherit from both the generated model and validation mixin

## Adding New Validation

To add validation to a model class:

1. Create a validation mixin class in this module:
   ```python
   class MyModelValidationMixin:
       @model_validator(mode='after')
       def validate_my_constraints(self):
           # Your validation logic here
           if some_condition:
               raise ValueError("Validation message")
           return self
   ```

2. Apply the mixin in schema.py:
   ```python
   from ._schema import MyModel as _MyModel
   from ._schema_validation import MyModelValidationMixin
   
   class MyModel(MyModelValidationMixin, _MyModel):
       pass
   ```

3. Export the validated class in schema.py's __all__ list

## Guidelines

- Use descriptive error messages that guide users toward correct usage
- Prefer @model_validator(mode='after') for cross-field validation
- Use hasattr() checks when validating optional or conditional fields
- Keep validation logic focused on business rules, not basic type checking
- Document complex validation rules with examples
"""

from pydantic import model_validator
from ._schema import DimensionType


class DimensionValidationMixin:
    """
    Validation mixin for Dimension objects.
    
    Enforces business rules that cannot be expressed in JSON Schema:
    - Index dimensions must have 'index' unit (JSON Schema if-then constraints
      are not supported by datamodel-codegen)
    
    Example:
        # Valid index dimension
        Dimension(id="i", unit="index", type=DimensionType.index)
        
        # Invalid - will raise ValueError
        Dimension(id="i", unit="micrometers", type=DimensionType.index)
    """
    
    @model_validator(mode='after')
    def validate_dimension_constraints(self):
        """
        Validate dimension-specific business rules.
        
        Enforces that index-type dimensions must use "index" as their unit.
        This constraint is defined in the JSON Schema using if-then logic,
        but datamodel-codegen cannot generate equivalent Pydantic validation.
        
        Raises:
            ValueError: If an index dimension has a non-"index" unit
        """
        if hasattr(self, 'type') and hasattr(self, 'unit'):
            if self.type == DimensionType.index and self.unit != "index":
                raise ValueError("Index dimensions must have 'index' unit")
        return self